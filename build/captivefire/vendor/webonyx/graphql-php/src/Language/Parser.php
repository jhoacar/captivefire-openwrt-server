<?php  declare(strict_types=1);namespace GraphQL\Language;use GraphQL\Error\SyntaxError;use GraphQL\Language\AST\ArgumentNode;use GraphQL\Language\AST\BooleanValueNode;use GraphQL\Language\AST\DirectiveDefinitionNode;use GraphQL\Language\AST\DirectiveNode;use GraphQL\Language\AST\DocumentNode;use GraphQL\Language\AST\EnumTypeDefinitionNode;use GraphQL\Language\AST\EnumTypeExtensionNode;use GraphQL\Language\AST\EnumValueDefinitionNode;use GraphQL\Language\AST\EnumValueNode;use GraphQL\Language\AST\ExecutableDefinitionNode;use GraphQL\Language\AST\FieldDefinitionNode;use GraphQL\Language\AST\FieldNode;use GraphQL\Language\AST\FloatValueNode;use GraphQL\Language\AST\FragmentDefinitionNode;use GraphQL\Language\AST\FragmentSpreadNode;use GraphQL\Language\AST\InlineFragmentNode;use GraphQL\Language\AST\InputObjectTypeDefinitionNode;use GraphQL\Language\AST\InputObjectTypeExtensionNode;use GraphQL\Language\AST\InputValueDefinitionNode;use GraphQL\Language\AST\InterfaceTypeDefinitionNode;use GraphQL\Language\AST\InterfaceTypeExtensionNode;use GraphQL\Language\AST\IntValueNode;use GraphQL\Language\AST\ListTypeNode;use GraphQL\Language\AST\ListValueNode;use GraphQL\Language\AST\Location;use GraphQL\Language\AST\NamedTypeNode;use GraphQL\Language\AST\NameNode;use GraphQL\Language\AST\NodeList;use GraphQL\Language\AST\NonNullTypeNode;use GraphQL\Language\AST\NullValueNode;use GraphQL\Language\AST\ObjectFieldNode;use GraphQL\Language\AST\ObjectTypeDefinitionNode;use GraphQL\Language\AST\ObjectTypeExtensionNode;use GraphQL\Language\AST\ObjectValueNode;use GraphQL\Language\AST\OperationDefinitionNode;use GraphQL\Language\AST\OperationTypeDefinitionNode;use GraphQL\Language\AST\ScalarTypeDefinitionNode;use GraphQL\Language\AST\ScalarTypeExtensionNode;use GraphQL\Language\AST\SchemaDefinitionNode;use GraphQL\Language\AST\SchemaTypeExtensionNode;use GraphQL\Language\AST\SelectionSetNode;use GraphQL\Language\AST\StringValueNode;use GraphQL\Language\AST\TypeExtensionNode;use GraphQL\Language\AST\TypeSystemDefinitionNode;use GraphQL\Language\AST\UnionTypeDefinitionNode;use GraphQL\Language\AST\UnionTypeExtensionNode;use GraphQL\Language\AST\VariableDefinitionNode;use GraphQL\Language\AST\VariableNode;use function count;use function sprintf;class Parser{public static function parse($source,array $options=[]){$sourceObj=$source instanceof Source?$source:new Source($source);$parser=new self($sourceObj,$options);return $parser->parseDocument();}public static function parseValue($source,array $options=[]){$sourceObj=$source instanceof Source?$source:new Source($source);$parser=new Parser($sourceObj,$options);$parser->expect(Token::SOF);$value=$parser->parseValueLiteral(false);$parser->expect(Token::EOF);return $value;}public static function parseType($source,array $options=[]){$sourceObj=$source instanceof Source?$source:new Source($source);$parser=new Parser($sourceObj,$options);$parser->expect(Token::SOF);$type=$parser->parseTypeReference();$parser->expect(Token::EOF);return $type;}private $lexer;public function __construct(Source $source,array $options=[]){$this->lexer=new Lexer($source,$options);}private function loc(Token $startToken){if(empty($this->lexer->options['noLocation'])){return new Location($startToken,$this->lexer->lastToken,$this->lexer->source);}return null;}private function peek($kind){return $this->lexer->token->kind ===$kind;}private function skip($kind){$match=$this->lexer->token->kind ===$kind;if($match){$this->lexer->advance();}return $match;}private function expect($kind){$token=$this->lexer->token;if($token->kind ===$kind){$this->lexer->advance();return $token;}throw new SyntaxError($this->lexer->source,$token->start,sprintf('Expected %s, found %s',$kind,$token->getDescription()));}private function expectKeyword($value){$token=$this->lexer->token;if($token->kind ===Token::NAME &&$token->value ===$value){$this->lexer->advance();return $token;}throw new SyntaxError($this->lexer->source,$token->start,'Expected "'.$value.'", found '.$token->getDescription());}private function unexpected(?Token $atToken=null){$token=$atToken?:$this->lexer->token;return new SyntaxError($this->lexer->source,$token->start,'Unexpected '.$token->getDescription());}private function any($openKind,$parseFn,$closeKind){$this->expect($openKind);$nodes=[];while(!$this->skip($closeKind)){$nodes[]=$parseFn($this);}return new NodeList($nodes);}private function many($openKind,$parseFn,$closeKind){$this->expect($openKind);$nodes=[$parseFn($this)];while(!$this->skip($closeKind)){$nodes[]=$parseFn($this);}return new NodeList($nodes);}private function parseName(){$token=$this->expect(Token::NAME);return new NameNode(['value' =>$token->value,'loc' =>$this->loc($token),]);}private function parseDocument(){$start=$this->lexer->token;$this->expect(Token::SOF);$definitions=[];do{$definitions[]=$this->parseDefinition();}while(!$this->skip(Token::EOF));return new DocumentNode(['definitions' =>new NodeList($definitions),'loc' =>$this->loc($start),]);}private function parseDefinition(){if($this->peek(Token::NAME)){switch($this->lexer->token->value){case  'query':case  'mutation':case  'subscription':case  'fragment':return $this->parseExecutableDefinition();case  'schema':case  'scalar':case  'type':case  'interface':case  'union':case  'enum':case  'input':case  'extend':case  'directive':return $this->parseTypeSystemDefinition();}}elseif($this->peek(Token::BRACE_L)){return $this->parseExecutableDefinition();}elseif($this->peekDescription()){return $this->parseTypeSystemDefinition();}throw $this->unexpected();}private function parseExecutableDefinition(){if($this->peek(Token::NAME)){switch($this->lexer->token->value){case  'query':case  'mutation':case  'subscription':return $this->parseOperationDefinition();case  'fragment':return $this->parseFragmentDefinition();}}elseif($this->peek(Token::BRACE_L)){return $this->parseOperationDefinition();}throw $this->unexpected();}private function parseOperationDefinition(){$start=$this->lexer->token;if($this->peek(Token::BRACE_L)){return new OperationDefinitionNode(['operation' =>'query','name' =>null,'variableDefinitions' =>new NodeList([]),'directives' =>new NodeList([]),'selectionSet' =>$this->parseSelectionSet(),'loc' =>$this->loc($start),]);}$operation=$this->parseOperationType();$name=null;if($this->peek(Token::NAME)){$name=$this->parseName();}return new OperationDefinitionNode(['operation' =>$operation,'name' =>$name,'variableDefinitions' =>$this->parseVariableDefinitions(),'directives' =>$this->parseDirectives(false),'selectionSet' =>$this->parseSelectionSet(),'loc' =>$this->loc($start),]);}private function parseOperationType(){$operationToken=$this->expect(Token::NAME);switch($operationToken->value){case  'query':return 'query';case  'mutation':return 'mutation';case  'subscription':return 'subscription';}throw $this->unexpected($operationToken);}private function parseVariableDefinitions(){return $this->peek(Token::PAREN_L)?$this->many(Token::PAREN_L,function(){return $this->parseVariableDefinition();},Token::PAREN_R):new NodeList([]);}private function parseVariableDefinition(){$start=$this->lexer->token;$var=$this->parseVariable();$this->expect(Token::COLON);$type=$this->parseTypeReference();return new VariableDefinitionNode(['variable' =>$var,'type' =>$type,'defaultValue' =>($this->skip(Token::EQUALS)?$this->parseValueLiteral(true):null),'loc' =>$this->loc($start),]);}private function parseVariable(){$start=$this->lexer->token;$this->expect(Token::DOLLAR);return new VariableNode(['name' =>$this->parseName(),'loc' =>$this->loc($start),]);}private function parseSelectionSet(){$start=$this->lexer->token;return new SelectionSetNode(['selections' =>$this->many(Token::BRACE_L,function(){return $this->parseSelection();},Token::BRACE_R),'loc' =>$this->loc($start),]);}private function parseSelection(){return $this->peek(Token::SPREAD)?$this->parseFragment():$this->parseField();}private function parseField(){$start=$this->lexer->token;$nameOrAlias=$this->parseName();if($this->skip(Token::COLON)){$alias=$nameOrAlias;$name=$this->parseName();}else{$alias=null;$name=$nameOrAlias;}return new FieldNode(['alias' =>$alias,'name' =>$name,'arguments' =>$this->parseArguments(false),'directives' =>$this->parseDirectives(false),'selectionSet' =>$this->peek(Token::BRACE_L)?$this->parseSelectionSet():null,'loc' =>$this->loc($start),]);}private function parseArguments($isConst){$parseFn=$isConst?function(){return $this->parseConstArgument();}:function(){return $this->parseArgument();};return $this->peek(Token::PAREN_L)?$this->many(Token::PAREN_L,$parseFn,Token::PAREN_R):new NodeList([]);}private function parseArgument(){$start=$this->lexer->token;$name=$this->parseName();$this->expect(Token::COLON);$value=$this->parseValueLiteral(false);return new ArgumentNode(['name' =>$name,'value' =>$value,'loc' =>$this->loc($start),]);}private function parseConstArgument(){$start=$this->lexer->token;$name=$this->parseName();$this->expect(Token::COLON);$value=$this->parseConstValue();return new ArgumentNode(['name' =>$name,'value' =>$value,'loc' =>$this->loc($start),]);}private function parseFragment(){$start=$this->lexer->token;$this->expect(Token::SPREAD);if($this->peek(Token::NAME)&&$this->lexer->token->value !=='on'){return new FragmentSpreadNode(['name' =>$this->parseFragmentName(),'directives' =>$this->parseDirectives(false),'loc' =>$this->loc($start),]);}$typeCondition=null;if($this->lexer->token->value ==='on'){$this->lexer->advance();$typeCondition=$this->parseNamedType();}return new InlineFragmentNode(['typeCondition' =>$typeCondition,'directives' =>$this->parseDirectives(false),'selectionSet' =>$this->parseSelectionSet(),'loc' =>$this->loc($start),]);}private function parseFragmentDefinition(){$start=$this->lexer->token;$this->expectKeyword('fragment');$name=$this->parseFragmentName();$variableDefinitions=null;if(isset($this->lexer->options['experimentalFragmentVariables'])){$variableDefinitions=$this->parseVariableDefinitions();}$this->expectKeyword('on');$typeCondition=$this->parseNamedType();return new FragmentDefinitionNode(['name' =>$name,'variableDefinitions' =>$variableDefinitions,'typeCondition' =>$typeCondition,'directives' =>$this->parseDirectives(false),'selectionSet' =>$this->parseSelectionSet(),'loc' =>$this->loc($start),]);}private function parseFragmentName(){if($this->lexer->token->value ==='on'){throw $this->unexpected();}return $this->parseName();}private function parseValueLiteral($isConst){$token=$this->lexer->token;switch($token->kind){case  Token::BRACKET_L:return $this->parseArray($isConst);case  Token::BRACE_L:return $this->parseObject($isConst);case  Token::INT:$this->lexer->advance();return new IntValueNode(['value' =>$token->value,'loc' =>$this->loc($token),]);case  Token::FLOAT:$this->lexer->advance();return new FloatValueNode(['value' =>$token->value,'loc' =>$this->loc($token),]);case  Token::STRING:case  Token::BLOCK_STRING:return $this->parseStringLiteral();case  Token::NAME:if($token->value ==='true' ||$token->value ==='false'){$this->lexer->advance();return new BooleanValueNode(['value' =>$token->value ==='true','loc' =>$this->loc($token),]);}if($token->value ==='null'){$this->lexer->advance();return new NullValueNode(['loc' =>$this->loc($token),]);}else{$this->lexer->advance();return new EnumValueNode(['value' =>$token->value,'loc' =>$this->loc($token),]);}break;case  Token::DOLLAR:if(!$isConst){return $this->parseVariable();}break;}throw $this->unexpected();}private function parseStringLiteral(){$token=$this->lexer->token;$this->lexer->advance();return new StringValueNode(['value' =>$token->value,'block' =>$token->kind ===Token::BLOCK_STRING,'loc' =>$this->loc($token),]);}private function parseConstValue(){return $this->parseValueLiteral(true);}private function parseVariableValue(){return $this->parseValueLiteral(false);}private function parseArray($isConst){$start=$this->lexer->token;$parseFn=$isConst?function(){return $this->parseConstValue();}:function(){return $this->parseVariableValue();};return new ListValueNode(['values' =>$this->any(Token::BRACKET_L,$parseFn,Token::BRACKET_R),'loc' =>$this->loc($start),]);}private function parseObject($isConst){$start=$this->lexer->token;$this->expect(Token::BRACE_L);$fields=[];while(!$this->skip(Token::BRACE_R)){$fields[]=$this->parseObjectField($isConst);}return new ObjectValueNode(['fields' =>new NodeList($fields),'loc' =>$this->loc($start),]);}private function parseObjectField($isConst){$start=$this->lexer->token;$name=$this->parseName();$this->expect(Token::COLON);return new ObjectFieldNode(['name' =>$name,'value' =>$this->parseValueLiteral($isConst),'loc' =>$this->loc($start),]);}private function parseDirectives($isConst){$directives=[];while($this->peek(Token::AT)){$directives[]=$this->parseDirective($isConst);}return new NodeList($directives);}private function parseDirective($isConst){$start=$this->lexer->token;$this->expect(Token::AT);return new DirectiveNode(['name' =>$this->parseName(),'arguments' =>$this->parseArguments($isConst),'loc' =>$this->loc($start),]);}private function parseTypeReference(){$start=$this->lexer->token;if($this->skip(Token::BRACKET_L)){$type=$this->parseTypeReference();$this->expect(Token::BRACKET_R);$type=new ListTypeNode(['type' =>$type,'loc' =>$this->loc($start),]);}else{$type=$this->parseNamedType();}if($this->skip(Token::BANG)){return new NonNullTypeNode(['type' =>$type,'loc' =>$this->loc($start),]);}return $type;}private function parseNamedType(){$start=$this->lexer->token;return new NamedTypeNode(['name' =>$this->parseName(),'loc' =>$this->loc($start),]);}private function parseTypeSystemDefinition(){$keywordToken=$this->peekDescription()?$this->lexer->lookahead():$this->lexer->token;if($keywordToken->kind ===Token::NAME){switch($keywordToken->value){case  'schema':return $this->parseSchemaDefinition();case  'scalar':return $this->parseScalarTypeDefinition();case  'type':return $this->parseObjectTypeDefinition();case  'interface':return $this->parseInterfaceTypeDefinition();case  'union':return $this->parseUnionTypeDefinition();case  'enum':return $this->parseEnumTypeDefinition();case  'input':return $this->parseInputObjectTypeDefinition();case  'extend':return $this->parseTypeExtension();case  'directive':return $this->parseDirectiveDefinition();}}throw $this->unexpected($keywordToken);}private function peekDescription(){return $this->peek(Token::STRING)||$this->peek(Token::BLOCK_STRING);}private function parseDescription(){if($this->peekDescription()){return $this->parseStringLiteral();}}private function parseSchemaDefinition(){$start=$this->lexer->token;$this->expectKeyword('schema');$directives=$this->parseDirectives(true);$operationTypes=$this->many(Token::BRACE_L,function(){return $this->parseOperationTypeDefinition();},Token::BRACE_R);return new SchemaDefinitionNode(['directives' =>$directives,'operationTypes' =>$operationTypes,'loc' =>$this->loc($start),]);}private function parseOperationTypeDefinition(){$start=$this->lexer->token;$operation=$this->parseOperationType();$this->expect(Token::COLON);$type=$this->parseNamedType();return new OperationTypeDefinitionNode(['operation' =>$operation,'type' =>$type,'loc' =>$this->loc($start),]);}private function parseScalarTypeDefinition(){$start=$this->lexer->token;$description=$this->parseDescription();$this->expectKeyword('scalar');$name=$this->parseName();$directives=$this->parseDirectives(true);return new ScalarTypeDefinitionNode(['name' =>$name,'directives' =>$directives,'loc' =>$this->loc($start),'description' =>$description,]);}private function parseObjectTypeDefinition(){$start=$this->lexer->token;$description=$this->parseDescription();$this->expectKeyword('type');$name=$this->parseName();$interfaces=$this->parseImplementsInterfaces();$directives=$this->parseDirectives(true);$fields=$this->parseFieldsDefinition();return new ObjectTypeDefinitionNode(['name' =>$name,'interfaces' =>$interfaces,'directives' =>$directives,'fields' =>$fields,'loc' =>$this->loc($start),'description' =>$description,]);}private function parseImplementsInterfaces(){$types=[];if($this->lexer->token->value ==='implements'){$this->lexer->advance();$this->skip(Token::AMP);do{$types[]=$this->parseNamedType();}while($this->skip(Token::AMP)||(!empty($this->lexer->options['allowLegacySDLImplementsInterfaces'])&&$this->peek(Token::NAME)));}return $types;}private function parseFieldsDefinition(){if(!empty($this->lexer->options['allowLegacySDLEmptyFields'])&&$this->peek(Token::BRACE_L)&&$this->lexer->lookahead()->kind ===Token::BRACE_R){$this->lexer->advance();$this->lexer->advance();return[];}return $this->peek(Token::BRACE_L)?$this->many(Token::BRACE_L,function(){return $this->parseFieldDefinition();},Token::BRACE_R):new NodeList([]);}private function parseFieldDefinition(){$start=$this->lexer->token;$description=$this->parseDescription();$name=$this->parseName();$args=$this->parseArgumentDefs();$this->expect(Token::COLON);$type=$this->parseTypeReference();$directives=$this->parseDirectives(true);return new FieldDefinitionNode(['name' =>$name,'arguments' =>$args,'type' =>$type,'directives' =>$directives,'loc' =>$this->loc($start),'description' =>$description,]);}private function parseArgumentDefs(){if(!$this->peek(Token::PAREN_L)){return new NodeList([]);}return $this->many(Token::PAREN_L,function(){return $this->parseInputValueDef();},Token::PAREN_R);}private function parseInputValueDef(){$start=$this->lexer->token;$description=$this->parseDescription();$name=$this->parseName();$this->expect(Token::COLON);$type=$this->parseTypeReference();$defaultValue=null;if($this->skip(Token::EQUALS)){$defaultValue=$this->parseConstValue();}$directives=$this->parseDirectives(true);return new InputValueDefinitionNode(['name' =>$name,'type' =>$type,'defaultValue' =>$defaultValue,'directives' =>$directives,'loc' =>$this->loc($start),'description' =>$description,]);}private function parseInterfaceTypeDefinition(){$start=$this->lexer->token;$description=$this->parseDescription();$this->expectKeyword('interface');$name=$this->parseName();$directives=$this->parseDirectives(true);$fields=$this->parseFieldsDefinition();return new InterfaceTypeDefinitionNode(['name' =>$name,'directives' =>$directives,'fields' =>$fields,'loc' =>$this->loc($start),'description' =>$description,]);}private function parseUnionTypeDefinition(){$start=$this->lexer->token;$description=$this->parseDescription();$this->expectKeyword('union');$name=$this->parseName();$directives=$this->parseDirectives(true);$types=$this->parseUnionMemberTypes();return new UnionTypeDefinitionNode(['name' =>$name,'directives' =>$directives,'types' =>$types,'loc' =>$this->loc($start),'description' =>$description,]);}private function parseUnionMemberTypes(){$types=[];if($this->skip(Token::EQUALS)){$this->skip(Token::PIPE);do{$types[]=$this->parseNamedType();}while($this->skip(Token::PIPE));}return $types;}private function parseEnumTypeDefinition(){$start=$this->lexer->token;$description=$this->parseDescription();$this->expectKeyword('enum');$name=$this->parseName();$directives=$this->parseDirectives(true);$values=$this->parseEnumValuesDefinition();return new EnumTypeDefinitionNode(['name' =>$name,'directives' =>$directives,'values' =>$values,'loc' =>$this->loc($start),'description' =>$description,]);}private function parseEnumValuesDefinition(){return $this->peek(Token::BRACE_L)?$this->many(Token::BRACE_L,function(){return $this->parseEnumValueDefinition();},Token::BRACE_R):new NodeList([]);}private function parseEnumValueDefinition(){$start=$this->lexer->token;$description=$this->parseDescription();$name=$this->parseName();$directives=$this->parseDirectives(true);return new EnumValueDefinitionNode(['name' =>$name,'directives' =>$directives,'loc' =>$this->loc($start),'description' =>$description,]);}private function parseInputObjectTypeDefinition(){$start=$this->lexer->token;$description=$this->parseDescription();$this->expectKeyword('input');$name=$this->parseName();$directives=$this->parseDirectives(true);$fields=$this->parseInputFieldsDefinition();return new InputObjectTypeDefinitionNode(['name' =>$name,'directives' =>$directives,'fields' =>$fields,'loc' =>$this->loc($start),'description' =>$description,]);}private function parseInputFieldsDefinition(){return $this->peek(Token::BRACE_L)?$this->many(Token::BRACE_L,function(){return $this->parseInputValueDef();},Token::BRACE_R):new NodeList([]);}private function parseTypeExtension(){$keywordToken=$this->lexer->lookahead();if($keywordToken->kind ===Token::NAME){switch($keywordToken->value){case  'schema':return $this->parseSchemaTypeExtension();case  'scalar':return $this->parseScalarTypeExtension();case  'type':return $this->parseObjectTypeExtension();case  'interface':return $this->parseInterfaceTypeExtension();case  'union':return $this->parseUnionTypeExtension();case  'enum':return $this->parseEnumTypeExtension();case  'input':return $this->parseInputObjectTypeExtension();}}throw $this->unexpected($keywordToken);}private function parseSchemaTypeExtension(){$start=$this->lexer->token;$this->expectKeyword('extend');$this->expectKeyword('schema');$directives=$this->parseDirectives(true);$operationTypes=$this->peek(Token::BRACE_L)?$this->many(Token::BRACE_L,[$this,'parseOperationTypeDefinition'],Token::BRACE_R):[];if(count($directives)===0&&count($operationTypes)===0){$this->unexpected();}return new SchemaTypeExtensionNode(['directives' =>$directives,'operationTypes' =>$operationTypes,'loc' =>$this->loc($start),]);}private function parseScalarTypeExtension(){$start=$this->lexer->token;$this->expectKeyword('extend');$this->expectKeyword('scalar');$name=$this->parseName();$directives=$this->parseDirectives(true);if(count($directives)===0){throw $this->unexpected();}return new ScalarTypeExtensionNode(['name' =>$name,'directives' =>$directives,'loc' =>$this->loc($start),]);}private function parseObjectTypeExtension(){$start=$this->lexer->token;$this->expectKeyword('extend');$this->expectKeyword('type');$name=$this->parseName();$interfaces=$this->parseImplementsInterfaces();$directives=$this->parseDirectives(true);$fields=$this->parseFieldsDefinition();if(count($interfaces)===0&&count($directives)===0&&count($fields)===0){throw $this->unexpected();}return new ObjectTypeExtensionNode(['name' =>$name,'interfaces' =>$interfaces,'directives' =>$directives,'fields' =>$fields,'loc' =>$this->loc($start),]);}private function parseInterfaceTypeExtension(){$start=$this->lexer->token;$this->expectKeyword('extend');$this->expectKeyword('interface');$name=$this->parseName();$directives=$this->parseDirectives(true);$fields=$this->parseFieldsDefinition();if(count($directives)===0&&count($fields)===0){throw $this->unexpected();}return new InterfaceTypeExtensionNode(['name' =>$name,'directives' =>$directives,'fields' =>$fields,'loc' =>$this->loc($start),]);}private function parseUnionTypeExtension(){$start=$this->lexer->token;$this->expectKeyword('extend');$this->expectKeyword('union');$name=$this->parseName();$directives=$this->parseDirectives(true);$types=$this->parseUnionMemberTypes();if(count($directives)===0&&!$types){throw $this->unexpected();}return new UnionTypeExtensionNode(['name' =>$name,'directives' =>$directives,'types' =>$types,'loc' =>$this->loc($start),]);}private function parseEnumTypeExtension(){$start=$this->lexer->token;$this->expectKeyword('extend');$this->expectKeyword('enum');$name=$this->parseName();$directives=$this->parseDirectives(true);$values=$this->parseEnumValuesDefinition();if(count($directives)===0&&count($values)===0){throw $this->unexpected();}return new EnumTypeExtensionNode(['name' =>$name,'directives' =>$directives,'values' =>$values,'loc' =>$this->loc($start),]);}private function parseInputObjectTypeExtension(){$start=$this->lexer->token;$this->expectKeyword('extend');$this->expectKeyword('input');$name=$this->parseName();$directives=$this->parseDirectives(true);$fields=$this->parseInputFieldsDefinition();if(count($directives)===0&&count($fields)===0){throw $this->unexpected();}return new InputObjectTypeExtensionNode(['name' =>$name,'directives' =>$directives,'fields' =>$fields,'loc' =>$this->loc($start),]);}private function parseDirectiveDefinition(){$start=$this->lexer->token;$description=$this->parseDescription();$this->expectKeyword('directive');$this->expect(Token::AT);$name=$this->parseName();$args=$this->parseArgumentDefs();$this->expectKeyword('on');$locations=$this->parseDirectiveLocations();return new DirectiveDefinitionNode(['name' =>$name,'arguments' =>$args,'locations' =>$locations,'loc' =>$this->loc($start),'description' =>$description,]);}private function parseDirectiveLocations(){$this->skip(Token::PIPE);$locations=[];do{$locations[]=$this->parseDirectiveLocation();}while($this->skip(Token::PIPE));return $locations;}private function parseDirectiveLocation(){$start=$this->lexer->token;$name=$this->parseName();if(DirectiveLocation::has($name->value)){return $name;}throw $this->unexpected($start);}}
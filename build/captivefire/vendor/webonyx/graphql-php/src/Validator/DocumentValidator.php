<?php  declare(strict_types=1);namespace GraphQL\Validator;use Exception;use GraphQL\Error\Error;use GraphQL\Language\AST\DocumentNode;use GraphQL\Language\Visitor;use GraphQL\Type\Definition\Type;use GraphQL\Type\Schema;use GraphQL\Utils\TypeInfo;use GraphQL\Validator\Rules\DisableIntrospection;use GraphQL\Validator\Rules\ExecutableDefinitions;use GraphQL\Validator\Rules\FieldsOnCorrectType;use GraphQL\Validator\Rules\FragmentsOnCompositeTypes;use GraphQL\Validator\Rules\KnownArgumentNames;use GraphQL\Validator\Rules\KnownArgumentNamesOnDirectives;use GraphQL\Validator\Rules\KnownDirectives;use GraphQL\Validator\Rules\KnownFragmentNames;use GraphQL\Validator\Rules\KnownTypeNames;use GraphQL\Validator\Rules\LoneAnonymousOperation;use GraphQL\Validator\Rules\LoneSchemaDefinition;use GraphQL\Validator\Rules\NoFragmentCycles;use GraphQL\Validator\Rules\NoUndefinedVariables;use GraphQL\Validator\Rules\NoUnusedFragments;use GraphQL\Validator\Rules\NoUnusedVariables;use GraphQL\Validator\Rules\OverlappingFieldsCanBeMerged;use GraphQL\Validator\Rules\PossibleFragmentSpreads;use GraphQL\Validator\Rules\ProvidedNonNullArguments;use GraphQL\Validator\Rules\ProvidedRequiredArgumentsOnDirectives;use GraphQL\Validator\Rules\QueryComplexity;use GraphQL\Validator\Rules\QueryDepth;use GraphQL\Validator\Rules\QuerySecurityRule;use GraphQL\Validator\Rules\ScalarLeafs;use GraphQL\Validator\Rules\UniqueArgumentNames;use GraphQL\Validator\Rules\UniqueDirectivesPerLocation;use GraphQL\Validator\Rules\UniqueFragmentNames;use GraphQL\Validator\Rules\UniqueInputFieldNames;use GraphQL\Validator\Rules\UniqueOperationNames;use GraphQL\Validator\Rules\UniqueVariableNames;use GraphQL\Validator\Rules\ValidationRule;use GraphQL\Validator\Rules\ValuesOfCorrectType;use GraphQL\Validator\Rules\VariablesAreInputTypes;use GraphQL\Validator\Rules\VariablesDefaultValueAllowed;use GraphQL\Validator\Rules\VariablesInAllowedPosition;use Throwable;use function array_filter;use function array_map;use function array_merge;use function count;use function implode;use function is_array;use function sprintf;class DocumentValidator{private static $rules=[];private static $defaultRules;private static $securityRules;private static $sdlRules;private static $initRules=false;public static function validate(Schema $schema,DocumentNode $ast,?array $rules=null,?TypeInfo $typeInfo=null){if($rules ===null){$rules=static::allRules();}if(is_array($rules)===true &&count($rules)===0){return[];}$typeInfo=$typeInfo?:new TypeInfo($schema);return static::visitUsingRules($schema,$typeInfo,$ast,$rules);}public static function allRules(){if(!self::$initRules){static::$rules=array_merge(static::defaultRules(),self::securityRules(),self::$rules);static::$initRules=true;}return self::$rules;}public static function defaultRules(){if(self::$defaultRules ===null){self::$defaultRules=[ExecutableDefinitions::class =>new ExecutableDefinitions(),UniqueOperationNames::class =>new UniqueOperationNames(),LoneAnonymousOperation::class =>new LoneAnonymousOperation(),KnownTypeNames::class =>new KnownTypeNames(),FragmentsOnCompositeTypes::class =>new FragmentsOnCompositeTypes(),VariablesAreInputTypes::class =>new VariablesAreInputTypes(),ScalarLeafs::class =>new ScalarLeafs(),FieldsOnCorrectType::class =>new FieldsOnCorrectType(),UniqueFragmentNames::class =>new UniqueFragmentNames(),KnownFragmentNames::class =>new KnownFragmentNames(),NoUnusedFragments::class =>new NoUnusedFragments(),PossibleFragmentSpreads::class =>new PossibleFragmentSpreads(),NoFragmentCycles::class =>new NoFragmentCycles(),UniqueVariableNames::class =>new UniqueVariableNames(),NoUndefinedVariables::class =>new NoUndefinedVariables(),NoUnusedVariables::class =>new NoUnusedVariables(),KnownDirectives::class =>new KnownDirectives(),UniqueDirectivesPerLocation::class =>new UniqueDirectivesPerLocation(),KnownArgumentNames::class =>new KnownArgumentNames(),UniqueArgumentNames::class =>new UniqueArgumentNames(),ValuesOfCorrectType::class =>new ValuesOfCorrectType(),ProvidedNonNullArguments::class =>new ProvidedNonNullArguments(),VariablesDefaultValueAllowed::class =>new VariablesDefaultValueAllowed(),VariablesInAllowedPosition::class =>new VariablesInAllowedPosition(),OverlappingFieldsCanBeMerged::class =>new OverlappingFieldsCanBeMerged(),UniqueInputFieldNames::class =>new UniqueInputFieldNames(),];}return self::$defaultRules;}public static function securityRules(){if(self::$securityRules ===null){self::$securityRules=[DisableIntrospection::class =>new DisableIntrospection(DisableIntrospection::DISABLED),QueryDepth::class =>new QueryDepth(QueryDepth::DISABLED),QueryComplexity::class =>new QueryComplexity(QueryComplexity::DISABLED),];}return self::$securityRules;}public static function sdlRules(){if(self::$sdlRules ===null){self::$sdlRules=[LoneSchemaDefinition::class =>new LoneSchemaDefinition(),KnownDirectives::class =>new KnownDirectives(),KnownArgumentNamesOnDirectives::class =>new KnownArgumentNamesOnDirectives(),UniqueDirectivesPerLocation::class =>new UniqueDirectivesPerLocation(),UniqueArgumentNames::class =>new UniqueArgumentNames(),UniqueInputFieldNames::class =>new UniqueInputFieldNames(),ProvidedRequiredArgumentsOnDirectives::class =>new ProvidedRequiredArgumentsOnDirectives(),];}return self::$sdlRules;}public static function visitUsingRules(Schema $schema,TypeInfo $typeInfo,DocumentNode $documentNode,array $rules){$context=new ValidationContext($schema,$documentNode,$typeInfo);$visitors=[];foreach($rules as $rule){$visitors[]=$rule->getVisitor($context);}Visitor::visit($documentNode,Visitor::visitWithTypeInfo($typeInfo,Visitor::visitInParallel($visitors)));return $context->getErrors();}public static function getRule($name){$rules=static::allRules();if(isset($rules[$name])){return $rules[$name];}$name=sprintf('GraphQL\\Validator\\Rules\\%s',$name);return $rules[$name]??null;}public static function addRule(ValidationRule $rule){self::$rules[$rule->getName()]=$rule;}public static function isError($value){return is_array($value)?count(array_filter($value,static function($item){return $item instanceof Exception ||$item instanceof Throwable;}))===count($value):($value instanceof Exception ||$value instanceof Throwable);}public static function append(&$arr,$items){if(is_array($items)){$arr=array_merge($arr,$items);}else{$arr[]=$items;}return $arr;}public static function isValidLiteralValue(Type $type,$valueNode){$emptySchema=new Schema([]);$emptyDoc=new DocumentNode(['definitions' =>[]]);$typeInfo=new TypeInfo($emptySchema,$type);$context=new ValidationContext($emptySchema,$emptyDoc,$typeInfo);$validator=new ValuesOfCorrectType();$visitor=$validator->getVisitor($context);Visitor::visit($valueNode,Visitor::visitWithTypeInfo($typeInfo,$visitor));return $context->getErrors();}public static function assertValidSDLExtension(DocumentNode $documentAST,Schema $schema){$errors=self::visitUsingRules($schema,new TypeInfo($schema),$documentAST,self::sdlRules());if(count($errors)!==0){throw new Error(implode("\n\n",array_map(static function(Error $error):string{return $error->message;},$errors)));}}}
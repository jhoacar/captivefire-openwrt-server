<?php  declare(strict_types=1);namespace GraphQL\Validator\Rules;use GraphQL\Error\Error;use GraphQL\Language\AST\FragmentSpreadNode;use GraphQL\Language\AST\InlineFragmentNode;use GraphQL\Language\AST\NodeKind;use GraphQL\Type\Definition\AbstractType;use GraphQL\Type\Definition\CompositeType;use GraphQL\Type\Definition\InterfaceType;use GraphQL\Type\Definition\ObjectType;use GraphQL\Type\Definition\UnionType;use GraphQL\Type\Schema;use GraphQL\Utils\TypeInfo;use GraphQL\Validator\ValidationContext;use function sprintf;class PossibleFragmentSpreads extends ValidationRule{public function getVisitor(ValidationContext $context){return[NodeKind::INLINE_FRAGMENT =>function(InlineFragmentNode $node)use($context){$fragType=$context->getType();$parentType=$context->getParentType();if(!($fragType instanceof CompositeType)||!($parentType instanceof CompositeType)||$this->doTypesOverlap($context->getSchema(),$fragType,$parentType)){return;}$context->reportError(new Error(self::typeIncompatibleAnonSpreadMessage($parentType,$fragType),[$node]));},NodeKind::FRAGMENT_SPREAD =>function(FragmentSpreadNode $node)use($context){$fragName=$node->name->value;$fragType=$this->getFragmentType($context,$fragName);$parentType=$context->getParentType();if(!$fragType ||!$parentType ||$this->doTypesOverlap($context->getSchema(),$fragType,$parentType)){return;}$context->reportError(new Error(self::typeIncompatibleSpreadMessage($fragName,$parentType,$fragType),[$node]));},];}private function doTypesOverlap(Schema $schema,CompositeType $fragType,CompositeType $parentType){if($parentType ===$fragType){return true;}if($parentType instanceof AbstractType &&$fragType instanceof ObjectType){return $schema->isPossibleType($parentType,$fragType);}if($parentType instanceof ObjectType &&$fragType instanceof AbstractType){return $schema->isPossibleType($fragType,$parentType);}if($parentType instanceof ObjectType &&$fragType instanceof ObjectType){return $parentType ===$fragType;}if($parentType instanceof InterfaceType &&$fragType instanceof InterfaceType){return true;}if($parentType instanceof UnionType &&$fragType instanceof InterfaceType){foreach($parentType->getTypes()as $type){if($type->implementsInterface($fragType)){return true;}}}if($parentType instanceof InterfaceType &&$fragType instanceof UnionType){foreach($fragType->getTypes()as $type){if($type->implementsInterface($parentType)){return true;}}}if($parentType instanceof UnionType &&$fragType instanceof UnionType){foreach($fragType->getTypes()as $type){if($parentType->isPossibleType($type)){return true;}}}return false;}public static function typeIncompatibleAnonSpreadMessage($parentType,$fragType){return sprintf('Fragment cannot be spread here as objects of type "%s" can never be of type "%s".',$parentType,$fragType);}private function getFragmentType(ValidationContext $context,$name){$frag=$context->getFragment($name);if($frag){$type=TypeInfo::typeFromAST($context->getSchema(),$frag->typeCondition);if($type instanceof CompositeType){return $type;}}return null;}public static function typeIncompatibleSpreadMessage($fragName,$parentType,$fragType){return sprintf('Fragment "%s" cannot be spread here as objects of type "%s" can never be of type "%s".',$fragName,$parentType,$fragType);}}
<?php  declare(strict_types=1);namespace GraphQL\Validator\Rules;use GraphQL\Error\Error;use GraphQL\Language\AST\ArgumentNode;use GraphQL\Language\AST\FieldNode;use GraphQL\Language\AST\FragmentDefinitionNode;use GraphQL\Language\AST\FragmentSpreadNode;use GraphQL\Language\AST\InlineFragmentNode;use GraphQL\Language\AST\Node;use GraphQL\Language\AST\NodeKind;use GraphQL\Language\AST\SelectionSetNode;use GraphQL\Language\Printer;use GraphQL\Type\Definition\CompositeType;use GraphQL\Type\Definition\InterfaceType;use GraphQL\Type\Definition\ListOfType;use GraphQL\Type\Definition\NonNull;use GraphQL\Type\Definition\ObjectType;use GraphQL\Type\Definition\OutputType;use GraphQL\Type\Definition\Type;use GraphQL\Utils\PairSet;use GraphQL\Utils\TypeInfo;use GraphQL\Validator\ValidationContext;use SplObjectStorage;use function array_keys;use function array_map;use function array_merge;use function array_reduce;use function count;use function implode;use function is_array;use function sprintf;class OverlappingFieldsCanBeMerged extends ValidationRule{private $comparedFragmentPairs;private $cachedFieldsAndFragmentNames;public function getVisitor(ValidationContext $context){$this->comparedFragmentPairs=new PairSet();$this->cachedFieldsAndFragmentNames=new SplObjectStorage();return[NodeKind::SELECTION_SET =>function(SelectionSetNode $selectionSet)use($context){$conflicts=$this->findConflictsWithinSelectionSet($context,$context->getParentType(),$selectionSet);foreach($conflicts as $conflict){[[$responseName,$reason],$fields1,$fields2]=$conflict;$context->reportError(new Error(self::fieldsConflictMessage($responseName,$reason),array_merge($fields1,$fields2)));}},];}private function findConflictsWithinSelectionSet(ValidationContext $context,$parentType,SelectionSetNode $selectionSet){[$fieldMap,$fragmentNames]=$this->getFieldsAndFragmentNames($context,$parentType,$selectionSet);$conflicts=[];$this->collectConflictsWithin($context,$conflicts,$fieldMap);$fragmentNamesLength=count($fragmentNames);if($fragmentNamesLength !==0){$comparedFragments=[];for($i=0;$i<$fragmentNamesLength;$i++){$this->collectConflictsBetweenFieldsAndFragment($context,$conflicts,$comparedFragments,false,$fieldMap,$fragmentNames[$i]);for($j=$i+1;$j<$fragmentNamesLength;$j++){$this->collectConflictsBetweenFragments($context,$conflicts,false,$fragmentNames[$i],$fragmentNames[$j]);}}}return $conflicts;}private function getFieldsAndFragmentNames(ValidationContext $context,$parentType,SelectionSetNode $selectionSet){if(isset($this->cachedFieldsAndFragmentNames[$selectionSet])){$cached=$this->cachedFieldsAndFragmentNames[$selectionSet];}else{$astAndDefs=[];$fragmentNames=[];$this->internalCollectFieldsAndFragmentNames($context,$parentType,$selectionSet,$astAndDefs,$fragmentNames);$cached=[$astAndDefs,array_keys($fragmentNames)];$this->cachedFieldsAndFragmentNames[$selectionSet]=$cached;}return $cached;}private function internalCollectFieldsAndFragmentNames(ValidationContext $context,$parentType,SelectionSetNode $selectionSet,array&$astAndDefs,array&$fragmentNames){foreach($selectionSet->selections as $selection){switch(true){case  $selection instanceof FieldNode:$fieldName=$selection->name->value;$fieldDef=null;if($parentType instanceof ObjectType ||$parentType instanceof InterfaceType){$tmp=$parentType->getFields();if(isset($tmp[$fieldName])){$fieldDef=$tmp[$fieldName];}}$responseName=$selection->alias?$selection->alias->value:$fieldName;if(!isset($astAndDefs[$responseName])){$astAndDefs[$responseName]=[];}$astAndDefs[$responseName][]=[$parentType,$selection,$fieldDef];break;case  $selection instanceof FragmentSpreadNode:$fragmentNames[$selection->name->value]=true;break;case  $selection instanceof InlineFragmentNode:$typeCondition=$selection->typeCondition;$inlineFragmentType=$typeCondition?TypeInfo::typeFromAST($context->getSchema(),$typeCondition):$parentType;$this->internalCollectFieldsAndFragmentNames($context,$inlineFragmentType,$selection->selectionSet,$astAndDefs,$fragmentNames);break;}}}private function collectConflictsWithin(ValidationContext $context,array&$conflicts,array $fieldMap){foreach($fieldMap as $responseName =>$fields){$fieldsLength=count($fields);if($fieldsLength <=1){continue;}for($i=0;$i<$fieldsLength;$i++){for($j=$i+1;$j<$fieldsLength;$j++){$conflict=$this->findConflict($context,false,$responseName,$fields[$i],$fields[$j]);if(!$conflict){continue;}$conflicts[]=$conflict;}}}}private function findConflict(ValidationContext $context,$parentFieldsAreMutuallyExclusive,$responseName,array $field1,array $field2){[$parentType1,$ast1,$def1]=$field1;[$parentType2,$ast2,$def2]=$field2;$areMutuallyExclusive=$parentFieldsAreMutuallyExclusive ||($parentType1 !==$parentType2 &&$parentType1 instanceof ObjectType &&$parentType2 instanceof ObjectType);$type1=$def1 ===null?null:$def1->getType();$type2=$def2 ===null?null:$def2->getType();if(!$areMutuallyExclusive){$name1=$ast1->name->value;$name2=$ast2->name->value;if($name1 !==$name2){return[[$responseName,sprintf('%s and %s are different fields',$name1,$name2)],[$ast1],[$ast2],];}if(!$this->sameArguments($ast1->arguments?:[],$ast2->arguments?:[])){return[[$responseName,'they have differing arguments'],[$ast1],[$ast2],];}}if($type1 &&$type2 &&$this->doTypesConflict($type1,$type2)){return[[$responseName,sprintf('they return conflicting types %s and %s',$type1,$type2)],[$ast1],[$ast2],];}$selectionSet1=$ast1->selectionSet;$selectionSet2=$ast2->selectionSet;if($selectionSet1 &&$selectionSet2){$conflicts=$this->findConflictsBetweenSubSelectionSets($context,$areMutuallyExclusive,Type::getNamedType($type1),$selectionSet1,Type::getNamedType($type2),$selectionSet2);return $this->subfieldConflicts($conflicts,$responseName,$ast1,$ast2);}return null;}private function sameArguments($arguments1,$arguments2){if(count($arguments1)!==count($arguments2)){return false;}foreach($arguments1 as $argument1){$argument2=null;foreach($arguments2 as $argument){if($argument->name->value ===$argument1->name->value){$argument2=$argument;break;}}if(!$argument2){return false;}if(!$this->sameValue($argument1->value,$argument2->value)){return false;}}return true;}private function sameValue(Node $value1,Node $value2){return(!$value1 &&!$value2)||(Printer::doPrint($value1)===Printer::doPrint($value2));}private function doTypesConflict(OutputType $type1,OutputType $type2){if($type1 instanceof ListOfType){return $type2 instanceof ListOfType?$this->doTypesConflict($type1->getWrappedType(),$type2->getWrappedType()):true;}if($type2 instanceof ListOfType){return $type1 instanceof ListOfType?$this->doTypesConflict($type1->getWrappedType(),$type2->getWrappedType()):true;}if($type1 instanceof NonNull){return $type2 instanceof NonNull?$this->doTypesConflict($type1->getWrappedType(),$type2->getWrappedType()):true;}if($type2 instanceof NonNull){return $type1 instanceof NonNull?$this->doTypesConflict($type1->getWrappedType(),$type2->getWrappedType()):true;}if(Type::isLeafType($type1)||Type::isLeafType($type2)){return $type1 !==$type2;}return false;}private function findConflictsBetweenSubSelectionSets(ValidationContext $context,$areMutuallyExclusive,$parentType1,SelectionSetNode $selectionSet1,$parentType2,SelectionSetNode $selectionSet2){$conflicts=[];[$fieldMap1,$fragmentNames1]=$this->getFieldsAndFragmentNames($context,$parentType1,$selectionSet1);[$fieldMap2,$fragmentNames2]=$this->getFieldsAndFragmentNames($context,$parentType2,$selectionSet2);$this->collectConflictsBetween($context,$conflicts,$areMutuallyExclusive,$fieldMap1,$fieldMap2);$fragmentNames2Length=count($fragmentNames2);if($fragmentNames2Length !==0){$comparedFragments=[];for($j=0;$j<$fragmentNames2Length;$j++){$this->collectConflictsBetweenFieldsAndFragment($context,$conflicts,$comparedFragments,$areMutuallyExclusive,$fieldMap1,$fragmentNames2[$j]);}}$fragmentNames1Length=count($fragmentNames1);if($fragmentNames1Length !==0){$comparedFragments=[];for($i=0;$i<$fragmentNames1Length;$i++){$this->collectConflictsBetweenFieldsAndFragment($context,$conflicts,$comparedFragments,$areMutuallyExclusive,$fieldMap2,$fragmentNames1[$i]);}}for($i=0;$i<$fragmentNames1Length;$i++){for($j=0;$j<$fragmentNames2Length;$j++){$this->collectConflictsBetweenFragments($context,$conflicts,$areMutuallyExclusive,$fragmentNames1[$i],$fragmentNames2[$j]);}}return $conflicts;}private function collectConflictsBetween(ValidationContext $context,array&$conflicts,$parentFieldsAreMutuallyExclusive,array $fieldMap1,array $fieldMap2){foreach($fieldMap1 as $responseName =>$fields1){if(!isset($fieldMap2[$responseName])){continue;}$fields2=$fieldMap2[$responseName];$fields1Length=count($fields1);$fields2Length=count($fields2);for($i=0;$i<$fields1Length;$i++){for($j=0;$j<$fields2Length;$j++){$conflict=$this->findConflict($context,$parentFieldsAreMutuallyExclusive,$responseName,$fields1[$i],$fields2[$j]);if(!$conflict){continue;}$conflicts[]=$conflict;}}}}private function collectConflictsBetweenFieldsAndFragment(ValidationContext $context,array&$conflicts,array&$comparedFragments,$areMutuallyExclusive,array $fieldMap,$fragmentName){if(isset($comparedFragments[$fragmentName])){return;}$comparedFragments[$fragmentName]=true;$fragment=$context->getFragment($fragmentName);if(!$fragment){return;}[$fieldMap2,$fragmentNames2]=$this->getReferencedFieldsAndFragmentNames($context,$fragment);if($fieldMap ===$fieldMap2){return;}$this->collectConflictsBetween($context,$conflicts,$areMutuallyExclusive,$fieldMap,$fieldMap2);$fragmentNames2Length=count($fragmentNames2);for($i=0;$i<$fragmentNames2Length;$i++){$this->collectConflictsBetweenFieldsAndFragment($context,$conflicts,$comparedFragments,$areMutuallyExclusive,$fieldMap,$fragmentNames2[$i]);}}private function getReferencedFieldsAndFragmentNames(ValidationContext $context,FragmentDefinitionNode $fragment){if(isset($this->cachedFieldsAndFragmentNames[$fragment->selectionSet])){return $this->cachedFieldsAndFragmentNames[$fragment->selectionSet];}$fragmentType=TypeInfo::typeFromAST($context->getSchema(),$fragment->typeCondition);return $this->getFieldsAndFragmentNames($context,$fragmentType,$fragment->selectionSet);}private function collectConflictsBetweenFragments(ValidationContext $context,array&$conflicts,$areMutuallyExclusive,$fragmentName1,$fragmentName2){if($fragmentName1 ===$fragmentName2){return;}if($this->comparedFragmentPairs->has($fragmentName1,$fragmentName2,$areMutuallyExclusive)){return;}$this->comparedFragmentPairs->add($fragmentName1,$fragmentName2,$areMutuallyExclusive);$fragment1=$context->getFragment($fragmentName1);$fragment2=$context->getFragment($fragmentName2);if(!$fragment1 ||!$fragment2){return;}[$fieldMap1,$fragmentNames1]=$this->getReferencedFieldsAndFragmentNames($context,$fragment1);[$fieldMap2,$fragmentNames2]=$this->getReferencedFieldsAndFragmentNames($context,$fragment2);$this->collectConflictsBetween($context,$conflicts,$areMutuallyExclusive,$fieldMap1,$fieldMap2);$fragmentNames2Length=count($fragmentNames2);for($j=0;$j<$fragmentNames2Length;$j++){$this->collectConflictsBetweenFragments($context,$conflicts,$areMutuallyExclusive,$fragmentName1,$fragmentNames2[$j]);}$fragmentNames1Length=count($fragmentNames1);for($i=0;$i<$fragmentNames1Length;$i++){$this->collectConflictsBetweenFragments($context,$conflicts,$areMutuallyExclusive,$fragmentNames1[$i],$fragmentName2);}}private function subfieldConflicts(array $conflicts,$responseName,FieldNode $ast1,FieldNode $ast2){if(count($conflicts)===0){return null;}return[[$responseName,array_map(static function($conflict){return $conflict[0];},$conflicts),],array_reduce($conflicts,static function($allFields,$conflict){return array_merge($allFields,$conflict[1]);},[$ast1]),array_reduce($conflicts,static function($allFields,$conflict){return array_merge($allFields,$conflict[2]);},[$ast2]),];}public static function fieldsConflictMessage($responseName,$reason){$reasonMessage=self::reasonMessage($reason);return sprintf('Fields "%s" conflict because %s. Use different aliases on the fields to fetch both if this was intentional.',$responseName,$reasonMessage);}public static function reasonMessage($reason){if(is_array($reason)){$tmp=array_map(static function($tmp){[$responseName,$subReason]=$tmp;$reasonMessage=self::reasonMessage($subReason);return sprintf('subfields "%s" conflict because %s',$responseName,$reasonMessage);},$reason);return implode(' and ',$tmp);}return $reason;}}
<?php  declare(strict_types=1);namespace GraphQL\Type\Definition;use GraphQL\Error\Error;use GraphQL\Error\InvariantViolation;use GraphQL\Language\AST\FieldDefinitionNode;use GraphQL\Utils\Utils;use function is_array;use function is_callable;use function is_string;use function sprintf;class FieldDefinition{public const DEFAULT_COMPLEXITY_FN='GraphQL\Type\Definition\FieldDefinition::defaultComplexity';public $name;public $args;public $resolveFn;public $mapFn;public $description;public $deprecationReason;public $astNode;public $config;public $type;private $complexityFn;protected function __construct(array $config){$this->name=$config['name'];$this->type=$config['type'];$this->resolveFn=$config['resolve']??null;$this->mapFn=$config['map']??null;$this->args=isset($config['args'])?FieldArgument::createMap($config['args']):[];$this->description=$config['description']??null;$this->deprecationReason=$config['deprecationReason']??null;$this->astNode=$config['astNode']??null;$this->config=$config;$this->complexityFn=$config['complexity']??self::DEFAULT_COMPLEXITY_FN;}public static function defineFieldMap(Type $type,$fields){if(is_callable($fields)){$fields=$fields();}if(!is_array($fields)){throw new InvariantViolation(sprintf('%s fields must be an array or a callable which returns such an array.',$type->name));}$map=[];foreach($fields as $name =>$field){if(is_array($field)){if(!isset($field['name'])){if(!is_string($name)){throw new InvariantViolation(sprintf('%s fields must be an associative array with field names as keys or a function which returns such an array.',$type->name));}$field['name']=$name;}if(isset($field['args'])&&!is_array($field['args'])){throw new InvariantViolation(sprintf('%s.%s args must be an array.',$type->name,$name));}$fieldDef=self::create($field);}elseif($field instanceof self){$fieldDef=$field;}else{if(!is_string($name)||!$field){throw new InvariantViolation(sprintf('%s.%s field config must be an array, but got: %s',$type->name,$name,Utils::printSafe($field)));}$fieldDef=self::create(['name' =>$name,'type' =>$field]);}$map[$fieldDef->name]=$fieldDef;}return $map;}public static function create($field){return new self($field);}public static function defaultComplexity($childrenComplexity){return $childrenComplexity+1;}public function getArg($name){foreach($this->args?:[]as $arg){if($arg->name ===$name){return $arg;}}return null;}public function getType(){return $this->type;}public function isDeprecated(){return (bool) $this->deprecationReason;}public function getComplexityFn(){return $this->complexityFn;}public function assertValid(Type $parentType){try{Utils::assertValidName($this->name);}catch(Error $e){throw new InvariantViolation(sprintf('%s.%s: %s',$parentType->name,$this->name,$e->getMessage()));}Utils::invariant(!isset($this->config['isDeprecated']),sprintf('%s.%s should provide "deprecationReason" instead of "isDeprecated".',$parentType->name,$this->name));$type=$this->type;if($type instanceof WrappingType){$type=$type->getWrappedType(true);}Utils::invariant($type instanceof OutputType,sprintf('%s.%s field type must be Output Type but got: %s',$parentType->name,$this->name,Utils::printSafe($this->type)));Utils::invariant($this->resolveFn ===null ||is_callable($this->resolveFn),sprintf('%s.%s field resolver must be a function if provided, but got: %s',$parentType->name,$this->name,Utils::printSafe($this->resolveFn)));}}